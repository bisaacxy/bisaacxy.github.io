<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Customer View]]></title>
    <url>%2F2016%2F05%2F05%2Fcustomview%2F</url>
    <content type="text"><![CDATA[这是最后的效果图，借此实践来加深自己对于自定义 View 的理解，毕竟有很多地方方法没有实际用过和写过，是不清楚到底是什么功能的。 代码实现饼形图一般是拿来作为数据统计结果的展示的，那么饼形图中各个扇形的面积则是按照数据的多少量来生成。首先要做的，就是定义实体类：1234567891011121314public class PieData &#123;private float value;private String name;private float percent;private int color;private float angel;public PieData()&#123;&#125;;public PieData(String name, float value) &#123; this.name = name; this.value = value; &#125; //省略 getter 和 setter 方法&#125; 在 PieData 中我们定义了一共5个变量，value 和 name 显而易见，color 则是表示一个实例显示在饼形图中的颜色，而 angel 则表示（此处是单词错误，应该是 angle）这个扇形扫过的角度，定义这个变量的原因在于，绘制此扇形时，需要传入扫过的角度作为参数。 定义了实体类，接下来就是重点，定义我们的自定义 View 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class MyPie extends View &#123; //颜色列表 private int[] mColors = &#123;0xFFCCFF00, 0xFF6495ED, 0xFFE32636, 0xFF800000, 0xFF808000, 0xFFFF8C69, 0xFF808080, 0xFFE6B800, 0xFF7CFC00&#125;; Paint paint = new Paint(); //绘制图形的实例 private int width, height; //获取当前空间宽高 private int startAngel = 0; //第一个数据显示的开始角度 private ArrayList&lt;PieData&gt; data = new ArrayList&lt;&gt;(); public MyPie(Context context) &#123; this(context, null); Log.d("tag","constructor"); &#125; public MyPie(Context context, AttributeSet attrs) &#123; super(context, attrs); initPaint(); Log.d("tag","constructor"); &#125; private void initPaint() &#123; paint.setStyle(Paint.Style.FILL); paint.setAntiAlias(true); &#125; private void initData() &#123; Log.d("initData()", "--------------初始化数据开始！-------------"); if (data == null || data.size() &lt; 0) &#123; Log.d("initData()", "数据为空,不符合要求"); return; &#125; float sumValue = 0; for (int i = 0; i &lt; data.size(); i++) &#123; PieData pie = data.get(i); sumValue += pie.getValue(); //计算数值和 System.out.println(sumValue); int j = i % mColors.length; //设置颜色 pie.setColor(mColors[j]); &#125; float sumAngle = 0; for (int i = 0; i &lt; data.size(); i++) &#123; PieData pie = data.get(i); System.out.println(pie.getValue()); float percentage = pie.getValue() / sumValue; // 百分比 float angle = percentage * 360;// 对应的角度 System.out.println(angle); pie.setPercent(percentage); // 记录百分比 pie.setAngel(angle); // 记录角度大小 sumAngle += angle; &#125; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); width = w; height = h; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Log.d("tag", "onDraw"); if (data == null) &#123; Log.d("onDraw", "没有数据所以无法绘制。"); return; &#125; float currentStartAngle = startAngel; // 当前起始角度 canvas.translate(width / 2, height / 2); // 将画布坐标原点移动到中心位置 float r = (float) (Math.min(width, height) / 2 * 0.8); // 饼状图半径 RectF rect = new RectF(-r, -r, r, r); // 饼状图绘制区域，圆弧的外接矩形 for (int i = 0; i &lt; data.size(); i++) &#123; PieData pie = data.get(i); paint.setColor(pie.getColor()); canvas.drawArc(rect, currentStartAngle, pie.getAngel(), true, paint); currentStartAngle += pie.getAngel(); &#125; &#125; public void setStartAngle(int angel) &#123; angel = startAngel; invalidate(); &#125; public void setPieData(ArrayList&lt;PieData&gt; data) &#123; this.data = data; initData(); invalidate();//获得数据后需要刷新组件 Log.d("tag", data.toString()); &#125;&#125; 首先看到我们定义了一个表示颜色的数组，到时候就从这个数组中给各个数据分配颜色。这里就不解释各个变量了，主要从方法来说，构造方法是一定要的，因为当这个 View 在 Activity 中被 findViewById 后，就会调用构造方法，所以应当利用好构造方法来进行一些变量的初始化，这里我们只初始化了 Paint 的实例，使其为填充的模式，据我现在的知识，自定义 View 中需要重点重写的几个方法分别是onMeasured , onDraw , onLayout , onSizeChanged。 onMeasure方法当前其实不需要，因为实现的这个控件并不需要 wrap_content 属性，所以在此不需要对其进行重写， onLayout 这个方法按照谷歌官方文档的解释是 Called when this view should assign a size and position to all of its children. 在我们的这个 View 中，并没有子 View 所以也就不需要重写这个方法了。 onSizeChanged方法则是在组件的宽高变化时回调，宽高是很重要的属性，我们可以看到，在获取饼状图的半径和移动画布中心的时候，都是需要组件的宽高来进行计算的，而组件设置的并不是具体的宽高值的话，就要根据情况来刷新组件了。 onDraw方法顾名思义，是对组件进行绘制，这个方法中给出一个 Canvas 对象，结合之前定义的 Paint 对象，就能够「用画笔在画布上画画了」。 以上是需要重写 View 父类的方法，同时也不要忘记初始化数据，因为PieData实例化时，成员变量只有 name 和 value ，需要根据总的数据量再来设置其中的 angel 和 percent。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探Python]]></title>
    <url>%2F2016%2F01%2F29%2FlearnPython%2F</url>
    <content type="text"><![CDATA[以下整理自自己的印象笔记，一开始在极客学院看视频，讲得感觉有点浅，后来找到了一些博客资料就弃掉了，自己对 Java 比较熟悉，所以记下的东西都是和 Java 有所不同的一些语法。Python 真是贴合自然语言容易看。 一些基本语法规则Python 是比较看重缩进的，以缩进来表示代码所在的区域。没有声明变量的过程，可以直接创建变量赋值，也没有变量类型限制(浮点和整型靠是否有小数点来表示了)，不强制需要添加在行末的 「;」，当然也可以通过添加来手动分行，否则会根据物理换行来换行。if 和 elseif 之后需要加冒号，基本上控制流都是需要添加 「:」，一般在 Java 中就是直接添加括号了。文件头通过# coding = utf-8来指明文件识别编码，因为 python 并不能识别utf-8，输出中文会出现错误 “non-ASCII charactor”循环语句上很简便，更加接近自然语言，通过 in range ( start , end ) 语句来指定范围 对象相关class 关键字定义类__init__ 来创建构造方法（简直简单） ChildClass ( ParentClass ) 表示继承这个父类假若父类有构造方法，那么子类也需要有一个构造方法，在父类的基础上进行扩展。 定义常量：使用类来创建模块来实现常量的模式 const1234567891011121314import sysclass _const(object): class ConstError(TypeError): pass def __setattr__(self, key, value): if self.__dict__.has_key(key): raise self.ConstError, "Can't rebind const(%s)" % key self.__dict__[key] = value def __delattr__(self, item): if item in self.__dict__: raise self.ConstError, "Can't unbind const(%s)" % item raise NameError, itemsys.modules[__name__] = _const() 字符串单引号中可以使用双引号，双引号中也可以使用单引号。三引号 ‘’’ 包括的字符串是可以换行的，同时在输出的时候是会保留格式的。在字符串前加 r 会使得字符串中的转义符无效化使用 * N 会使得字符串重复 N 次。 子字符串：通过类似于数组的下标模式来获得字符串的子串（单个字符），获得一段字符的采取 [ n：m ] 的形式，截取n~m-1下标的字符子串，如果 n, m 值不标注的话则表示从开头开始（或一直到字符串末尾） format函数： print(&quot;item{0},{0},{1},{2}&quot;.format(i,2,3)） 以上的代码中，通过 {} 中的数字来表示format参数中的相应位置参数的值，这样使得不同数据类型拼接到字符串中，避免产生类型判断错误,还有 % 的使用 P.S. : Java 中的字符串用 「+」来连接的方式在这里仅仅能用于连接字符串，不能连接其余格式资料：飘逸的python - 增强的格式化字符串format函数 引入外部文件的做法 一种是通过 import FILENAME 的形式来引入文件，访问其中的类时总是要通过 FILENAME.CLASSNAME 来访问 通过 from FILE import CLASS 来进行引入文件中的某个类，这样声明类实例的时候，是不需要通过文件名来引用的 数据类型Python 中数组，用列表（list）来代替 a = [ 1, 2, 3 ] a.pop(1) #删除索引1的列表 还有叫元组的数据类型，通过 () 来定义，但是元组和列表的区别在于元组中的元素无法修改 集合（set），通过创建集合对象可以做交并差等运算，同时在集合中的数据元素会自动去重。比如 l1=set(&quot;ddddffff&quot;) print l1 这个输出是 set(‘d’,’f’) 字典（关联数组），用大括号 {} 括起来，代码： student={&quot;name&quot;:&quot;cxy&quot;,&quot;age&quot;:100} #声明 print student[&quot;name&quot;] student[&quot;sex&quot;]=&quot;man&quot; #添加元素 print student[&quot;sex&quot;] 可以看到，字典是一种类似于键值对的存储结构，要向字典中添加元素也很简单，直接在 []中写入元素名赋值即可。 关于标识符：标识符大小写敏感，第一个字母只能是字母或者是下划线。Python中的 &amp;，|，^ 分别是按位与，或，异或的操作符，又有 not and or 来表示非、与、或的逻辑判断。Python 中还有很简单的求幂运算使用 「**」 运算符就相当于求幂了。 「//」 是舍弃余数，取整数部分的运算~ 按位翻转，~x=-(x+1) 以上是初次接触 Python 感到的一些和之前学习语言不同的地方，只是一点点，还有一些现在看到了但是还不知道怎么回事的，之后弄清楚了逐步写出来 。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看了火星救援]]></title>
    <url>%2F2015%2F11%2F28%2Fpost%2F</url>
    <content type="text"><![CDATA[趁着周五没课马上跑去看，好早之前就听说火星救援的宣传和评价如何如何好，是一部硬科幻电影，我这种半吊子科幻迷自然也是感兴趣很久了，然后闲逛亚马逊的时候想着不如把原著先看了吧（埋下了坑），于是就买了火星救援的的kindle电子书（10块原价还是略贵啊，电影上映都不打个折），看了三天就看完了，整体来说小说不长，不过如果对于一些基本科学概念不清楚的话可能稍微费点力气吧，看完电影和书的感觉就是这确实是一本够硬的科幻作品，在微博上也看到了对作者的介绍，想不到竟然参加了魔兽争霸2的开发！+10分！说回到故事情节，一开始我只知道主角被丢在了火星，自然而然让我联想到了Lifeline这个游戏，话说当初这个游戏我玩到后面就没有等泰勒的busy时间了。。。直接各种跳过等待，快速读完了游戏，都是主角一人被独自丢在了外星球，Lifeline里还有异形生物，“幻”的程度要更深些啊，火星救援里主角待得时间更久，要解决水、空气、食物这些基本问题，还要想着怎么去能够让自己获救的地点，比如去阿瑞斯4号的MAV的距离是3200km,看到这个距离我真觉得靠着那小漫游车有点捉急。不过更加喜欢马克，因为泰勒的所有决定都要玩家来做，马克作为电影主角主动性就强很多了，感觉专业素质也要强啊，他就是嘴上喊着卧槽，其实挺冷静的处理各种问题，最终一个一个都搞定了。最出乎意料地在于他被连带着气闸室一起炸飞的这一段，我本以为他过上了吃土豆的小康生活快乐无忧只等想办法开车出发了，然后晚上就boom了，马克在EVA氧气会不足的情况下硬是自己把气闸室顶回了栖息仓，电影里把这一段修改了，可能是限于篇幅长度吧，之后的这种删改也有，比如穿越沙暴和快到达目标时侧翻在了陨石坑中的情节，所以我就要说了，看电影前不要看小说，电影难免会有删改，先看原著后再看电影，会把期望拉得更高一点，不否认电影的精彩，但是我看的时候就会因为少的一些剧情感到遗憾。因为在故事展现的是一个人类在这种孤独和困难的情况下，依然渴望生命，充满希望的情景，每一个阻碍主角的困难，都是对人类不屈意志的进一步体现。所以下次一定先看电影再看小说。 我很喜欢马克这个角色，上面也说到他是嘴上喊着卧槽，但还是认真解决问题，气闸室被炸了后，他的日志里就是我死定了这种话，然后第二篇日志就开始说自己要重新做人干翻火星，看到这样的地方总是被逗笑，觉得太有意思了，最喜欢的还是他和地球建立连接后的通讯中的一段向全世界转发 嘿！看这有一对大奶子—–&gt;(·Y·） 真是太会玩了！当然他在火星也是孤独的，说不在第一次和地球建立连接成功的时候也会痛哭出来，但是平常就是一个我们所说的段子手，也许就是他这样的性格让他一个人在火星上撑过了这么多天，能够冷静的计算各种数据，将自己活下去的机会量化出来，这才是理工科的骄傲（可是我数学烂啊呵呵） 说一个我认为是电影里的小彩蛋，看过魔戒的也肯定一眼就知道了波若莫再一次参加了埃尔隆德会议！ 宾叔也是从大叔变成了更老的大叔了啊。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇]]></title>
    <url>%2F2015%2F10%2F25%2Fwhy%2F</url>
    <content type="text"><![CDATA[为什么开了这样一个博客？以前是看着有的学长自己架了博客，搜索资料也多半都会搜到博客的内容，那时候对于博客这个东西是没有什么概念，也觉得好像没什么必要，都流行微博了还要博客做什么呢？但是在大三这个学期产生了“也许需要自己的一个博客”这样的想法，原因在于学的东西渐渐多起来，但是只是单单记在笔记本上或者印象笔记上，都是非常不方便的，一个是纸质的保存问题和不便携的缺点，印象笔记的排版和体验也一直是不行的（尤其要吐槽列表功能，一度想用印象笔记来取代keep作为TODO，但是打开速度和桌面插件显示都觉得不满意），所以想到： 果然还是开一个博客来做一些阶段性的总结，或者对某些技术的分析思考比较好，剩下的原因，首页也提到会写一些乱七八糟的东西哈哈哈，当然也不会多么乱七八糟，就是觉得摆着这么多书看了完了然后就这么忘了也可惜的，要是闲写个什么 读后感 也未尝不可，电影亦然。 既然开了博客，那么多久写个东西呢？恩在看的东西也是一堆，争取一个星期写一篇关于某个正在学习的技术的思考和总结，比如最近在看的 Java语言程序设计（进阶） 和算法的一些问题，说实话算法这一类问题真是让我想破头了，我还想看看C++，想看的东西总是很多啊。 总而言之，就是开了博客就要让这博客活下来。 P.S.: Markdown语法也是，貌似不能首行缩进。 选择Octopress? 一开始想用wordpress,但是平常还是太懒了，然后也没有做深入了解和研究，恰好看到octopress的视频介绍，就跟着一路搭建过来了，感觉用这个搭建博客的人还是很少啊，谷歌相关的资料的时候，都是OS X或者Linux系统的方法，windows的方法少。打算之后的博文先写个如何windows环境下用Octopress搭建博客吧。网上说wordpress有好有坏，说数据库管理只要崩了就扑街了，太过笨重之类的种种，反正我这偷懒先找到这个方法就先用这个搭建了吧，以后有机会再去摸一下wordpress哈哈。 2015/11/21 18:02:33更新 现在已经换成了hexo，一来是基于Node.js的这么潮流的东西确实很有趣，可以顺便学习下，而且octopress的codeblock功能谜一样的失灵了，作者更新也是很久之前的事情了，所以就用hexo了吧！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
